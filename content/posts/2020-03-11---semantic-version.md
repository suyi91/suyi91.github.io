---
title: "语义化版本"
date: "2020-03-11 22:00"
template: "post"
slug: "semantic-version"
description: "为了规范版本发布和简化依赖管理，应当了解\"语义化版本\"规则。"
tags:
  - "npm"
  - "semver"
draft: false
category: "开发"
socialImage: "semver.jpg"
---

最近的工作中一直负责着组内前端组件库的升级迭代，需要管理组件库的版本。由于发版的次数较多，版本直接从`1.0.0`飙到了`1.0.40`且缺少必要的文档，组件库使用方在升级的使用中也出现了一系列的不兼容问题😂。

经人提点，了解了`语义化版本(semantic version)`的概念，获益良多。

## 什么是语义化版本

语义化版本由三部分组成，格式为: `major.minor.patch`，三部分的递增规则如下:

- `major`主版本号：当做了不兼容的 API 修改，
- `minor`次版本号：当做了向下兼容的功能性新增，
- `patch`修订号：当做了向下兼容的问题修正。

> 开发的`pre`先行版本或编译元数据信息可以加到`major.minor.patch`的后面作为版本的延伸，例如: `webpack@5.0.0-beta.13`。

## 语义化版本的规范

> 这是semver规范(2.0.0)的说明原文[link](https://semver.org/lang/zh-CN/)，下边列举开发中需要注意的点。

1. `major.minor.patch`的每一部分数值都必须递增，不能倒序且大于0。各部分数值不可以在开头补0。
1. 一旦发版，该版本内容**不能**修改。如需修改必须发新版。
1. `major`版本为0标识包还处于快速开发中，包的Api还不稳定，可能随时会发生改变。
1. `1.0.0`版本通常是稳定版的标识，后续的发版需要遵守语义化版本规范。
1. 稳定版`major > 0`时，`patch`必须在只做了**向下兼容的修正**时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
1. 稳定版`major > 0`时，`minor`必须在做了**向下兼容的新功能**，或是**标记弃用部分功能**时可以递增；也可以在**大量的修正、改进、新功能加入**时可以递增。`minor`变化时`patch`必须清零。
1. `major`需要在加入了**不兼容的功能**时递增，也可以在发生了`minor`、`patch`级别的修改时递增。变化时`minor`和`patch`必须清零。
1. 先行版本加在`patch`版本之后，先加上一个“连接号”再加上一连串以句点分隔的标识符来修饰。标识符可选范围`[0-9A-Za-z-]`，使用`.`作为分隔符。禁止留白和补零。
    > 1.2.3-alpha.1
    >
    > 1.2.3-alpha.2
1. 编译元数据信息版本加在`patch`版本之后，先加上一个“加号”再加上一连串以句点分隔的标识符来修饰。标识符可选范围`[0-9A-Za-z-]`，使用`.`作为分隔符。禁止留白和补零。
1. 两个版本进行排序比较时，需根据优先级(`major` > `minor` > `patch` > `pre`)定义顺序进行差异比较，**编译元数据**不做比较。
    > 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1
    >
    > 1.0.0-alpha.1 < 1.0.0

## semver的应用

semver的一个常见场景是npm包管理。具体会在后面介绍。TODO:
